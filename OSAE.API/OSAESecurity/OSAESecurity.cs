using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.IO;
using System.Text;

namespace OSAE
{
    /// <summary>
    /// Class used for securing REST request to the OSA API service.
    /// </summary>
    public class OSAESecurity
    {
        #region Security Settings
        // This class is used for authorization, and User determination to allow or secure certain operations.
        // A 16 character or 32 byte API key is used to encrypt or decrypt the Username.
        private static OSAE.General.OSAELog Log = new OSAE.General.OSAELog("Security");

        // The passPhrase is the Rest API Key that was generated by the Rest plugin.
        static string keyString = OSAE.OSAEObjectPropertyManager.GetObjectPropertyValue("Rest", "APIKEY").Value;
        
        // Get the number of seconds that the Authentication Key will be vaild.
        static private int keyTime = Convert.ToInt32(OSAE.OSAEObjectPropertyManager.GetObjectPropertyValue("Rest", "ApiKeyTimeOut").Value);

        // Splits this time to 1/2 before and 1/2 after current system time. This allows of time setting differences.
        // The cloerer you can make your devices match your serve, the more secure it will be!
        static double timeSplit = Convert.ToDouble(keyTime / 2);

        // The initVector is a 16 character string that is found in the System object properties under SecurityKey.
        // This property is also generated by the Rest Plugin.
        // The size of the IV (in bytes) must = (keysize / 8).  Default keysize is 256, so the IV must be
        // 32 bytes long.  Using a 16 character string here gives us 32 bytes when converted to a byte array.
        private static string ivString = OSAE.OSAEObjectPropertyManager.GetObjectPropertyValue("System", "SecurityKey").Value;

        // This constant is used to determine the keysize of the encryption algorithm
        private const int keysize = 256;
        #endregion

        #region Generate a Random Cryptographic Key
        private static string GenerateRandomCryptographicKey(int keyLength)
        {
            RNGCryptoServiceProvider rngCryptoServiceProvider = new RNGCryptoServiceProvider();
            byte[] randomBytes = new byte[keyLength];
            rngCryptoServiceProvider.GetBytes(randomBytes);
            return Convert.ToBase64String(randomBytes);
        }
        #endregion

        #region Encrypt string
        //Encrypt
        /// <summary>
        /// Encrypts the plainText using OSAE Security Encryption methods.
        /// </summary>
        /// <param name="plainText">The string to be encrypted</param>
        /// <returns>Returns an encrypted string created with OSAE Security Encryption methods</returns>
        public static string EncryptString(string plainText)
        {
            byte[] key = Encoding.ASCII.GetBytes(keyString);
            byte[] iv = Encoding.ASCII.GetBytes(ivString);
            byte[] encrypted;
            using (RijndaelManaged rijAlg = new RijndaelManaged())
            {
                rijAlg.Key = key;
                rijAlg.IV = iv;
                ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV);
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {
                            swEncrypt.Write(plainText);
                        }
                        encrypted = msEncrypt.ToArray();
                    }
                }
            }
            return Convert.ToBase64String(encrypted);
        }
        #endregion

        #region Decrypt Authentication Key
        //Decrypt
        /// <summary>
        /// Decrypts an OSAE Security encrypted Authentication string.
        /// </summary>
        /// <param name="authkey">An OSAE Security encrypted String</param>
        /// <returns>Returns the decrypted string containg: 'Username:TimeStamp:Password'</returns>
        public static string DecryptString(string AuthKey)
        {
            try
            {
                byte[] key = Encoding.ASCII.GetBytes(keyString);
                byte[] iv = Encoding.ASCII.GetBytes(ivString);
                byte[] cipherText = Convert.FromBase64String(AuthKey.Replace(' ', '+'));

                using (var rijndaelManaged =
                        new RijndaelManaged { Key = key, IV = iv, Mode = CipherMode.CBC })
                {
                    rijndaelManaged.BlockSize = 128;
                    rijndaelManaged.KeySize = 256;
                    using (var memoryStream =
                            new MemoryStream(cipherText))
                    using (var cryptoStream =
                            new CryptoStream(memoryStream,
                                rijndaelManaged.CreateDecryptor(key, iv),
                                CryptoStreamMode.Read))
                    {
                        return new StreamReader(cryptoStream).ReadToEnd();
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Error("Decryption error: ", ex);
                return null;
            }
        }
        #endregion

        #region Authorize trust from AuthKey
        // Authorize
        /// <summary>
        /// Decrypts an OSAE Security encrypted Authentication string, and compares trust level with the object being accessed.
        /// Used to verify User Trust in GET request
        /// </summary>
        /// <param name="authkey">An OSAE Security encrypted String</param>
        /// <param name="objName">The name of the OSAE Object being accessed</param>
        /// <returns>True or False, depending on criteria matches.</returns>
        public static Boolean Authorize(string authkey, string objName)
        {
            OSAEObject OSAEobj = OSAEObjectManager.GetObjectByName(objName);
            Log.Debug("OSAE Security is Decoding an AuthKey");
            Boolean auth = false;
            int uTrustLevel = 0;
            string decryptedAuthKey = DecryptString(authkey);
            string[] user = decryptedAuthKey.Split(':');
            try
            {
                OSAEObject ouser = OSAE.OSAEObjectManager.GetObjectByName(user[0]);
                Log.Debug("Found User: " + ouser);
                if (user[2] == OSAEObjectPropertyManager.GetObjectPropertyValue(ouser.Name, "Password").Value)
                {
                    DateTime authDate = new DateTime();
                    try
                    {
                        authDate = Convert.ToDateTime(user[1].Substring(0, 4) + "-" + user[1].Substring(4, 2) + "-" + user[1].Substring(6, 2) + " " + user[1].Substring(8, 2) + ":" + user[1].Substring(10, 2) + ":" + user[1].Substring(12, 2));
                    }
                    catch
                    {
                        Log.Debug("Could not resolve TimeStamp: FAILED");
                        return auth;
                    }
                    Log.Debug("Auth Date and Time: " + authDate.ToString());
                    //DateTime nowAuth = DateTime.Now;
                    DateTime sDate = DateTime.Now.AddSeconds(timeSplit - (timeSplit * 2));
                    DateTime eDate = DateTime.Now.AddSeconds(timeSplit);
                    if (authDate > sDate && authDate < eDate)
                    {
                        uTrustLevel = Convert.ToInt32(OSAEObjectPropertyManager.GetObjectPropertyValue(ouser.Name, "Trust Level").Value);
                        if (uTrustLevel > OSAEobj.MinTrustLevel)
                        {
                            Log.Debug("Authintication: PASSED");
                            auth = true;
                        }
                        else
                        {
                            Log.Debug("Trust Level too low. Access denied!");
                        }
                    }
                    else
                    {
                        Log.Debug("Authintication: FAILED");
                    }
                }
                else
                {
                    Log.Debug("Authintication: FAILED");
                }
            }
            catch
            {
                Log.Debug("Authintication: FAILED");
            }
            return auth;
        }
        #endregion

        #region Decrypt User from AuthKey
        /// <summary>
        /// Decrypts an OSAE Security encrypted Authentication string.
        /// Used to verify User to use in POST request.
	/// </summary>
        /// <param name="authkey">An OSAE Security encrypted String</param>
        /// <returns>Returns the Username, if criteria matches</returns>
        public static string DecryptUser(string authkey)
        {
            Log.Info("OSAE Security is Decoding an AuthKey");
            string uName = null;
            string decryptedAuthKey = DecryptString(authkey);
            string[] user = decryptedAuthKey.Split(':');
            try
            {
                OSAEObject ouser = OSAE.OSAEObjectManager.GetObjectByName(user[0]);
                Log.Debug("Found User: " + ouser);
                if (user[2] == OSAEObjectPropertyManager.GetObjectPropertyValue(ouser.Name, "Password").Value)
                {
                    DateTime authDate = new DateTime();
                    try
                    {
                        authDate = Convert.ToDateTime(user[1].Substring(0, 4) + "-" + user[1].Substring(4, 2) + "-" + user[1].Substring(6, 2) + " " + user[1].Substring(8, 2) + ":" + user[1].Substring(10, 2) + ":" + user[1].Substring(12, 2));
                    }
                    catch
                    {
                        Log.Debug("Could not resolve TimeStamp: FAILED");
                        return uName;
                    }
                    Log.Debug("Auth Date and Time: " + authDate.ToString());
                    //DateTime nowAuth = DateTime.Now;
                    DateTime sDate = DateTime.Now.AddSeconds(timeSplit - (timeSplit * 2));
                    DateTime eDate = DateTime.Now.AddSeconds(timeSplit);
                    if (authDate > sDate && authDate < eDate)
                    {
                        Log.Debug("Authintication: PASSED");
                        uName = ouser.Name;
                    }
                    else
                    {
                        Log.Debug("Authintication: FAILED");
                    }
                }
                else
                {
                    Log.Debug("Authintication: FAILED");
                }
            }
            catch
            {
                Log.Debug("Invalid Authintication key: FAILED");
            }
            return uName;
        }
        #endregion

        #region Generate a Current OSAE Security Authentication Key
        // Creates a current Authentication Key for the current user and timestamp.
        /// <summary>
        /// Creates a current Authentication Key for the current user and timestamp.
        /// </summary>
        /// <param name="currentUser">The name of the user to use for Authentication.</param>
        /// <returns>Returns a 64bit Encrypted Authentication Key</returns>
        public static string generateCurrentAuthKey(string currentUser)
        {
            OSAEObject cUser = OSAE.OSAEObjectManager.GetObjectByName(currentUser);
            string uname = cUser.Name;
            string uPass = OSAE.OSAEObjectPropertyManager.GetObjectPropertyValue(uname, "Password").Value;
            DateTime authDate = DateTime.Now;
            string authMonth = authDate.Month.ToString();
            if (authMonth.Length < 2) { authMonth = "0" + authMonth; }
            string authYear = authDate.Year.ToString();
            string authDay = authDate.Day.ToString();
            if (authDay.Length < 2) { authDay = "0" + authDay; }
            string authHour = authDate.Hour.ToString();
            if (authHour.Length < 2) { authHour = "0" + authHour; }
            string authMin = authDate.Minute.ToString();
            if (authMin.Length < 2) { authMin = "0" + authMin; }
            string authSec = authDate.Second.ToString();
            if (authSec.Length < 2) { authSec = "0" + authSec; }
            string timeStamp = authYear + "" + authMonth + "" + authDay + "" + authHour + "" + authMin + "" + authSec;
            string userPassDate = EncryptString(uname + ":" + timeStamp + ":" + uPass);
            return userPassDate;
        }
        #endregion

        #region Generate Rest API Key
        /// <summary>
        /// Returns a new Random API KEY.
        /// </summary>
        public static string GenerateAPIKey()
        {
            return GenerateRandomCryptographicKey(24);
        }
        #endregion

        #region Generate System Security Key
        /// <summary>
        /// Returns a new Random Security Key.
        /// </summary>
        public static string GenerateSecurityKey()
        {
            return GenerateRandomCryptographicKey(12);
        }
        #endregion
    }
}
